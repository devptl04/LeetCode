Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.
Return the number of good nodes in the binary tree.

Example 1:
Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -> (3,4) is the maximum value in the path starting from the root.
Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.

Constraints:
The number of nodes in the binary tree is in the range [1, 10^5].
Each node's value is between [-10^4, 10^4].

Code: Beats 100% Time Complexity O(n)
class Solution {
    public int goodNodes(TreeNode root) {
        return helper(root, Integer.MIN_VALUE);
    }

    public int helper(TreeNode root, int max){
        if (root == null) return 0;
        int count = root.val < max ? 0: 1;
        max = Math.max(max, root.val);

        return count + helper(root.left, max) + helper(root.right, max);
    }
}

Code Explanation: 
- For this problem, we want to see if the nodes that come before any given node are less than the current node. Essentially, each level of the binary tree should be less than its parent level
- We use DFS here to traverse the list and keep track of a max counter for each respective traversal path
- We initialize a helper DFS method that has the max value as well as the current node being processed. We then initialize a count variable that checks if the current node is considered a good node or bad (since our goal is to find the # of bad nodes)
- Then, we update the max for the current path accordingly and recursively call the next dfs while also adding the count variable. 
- We traverse through the whole tree once, so this is solved in linear time 
