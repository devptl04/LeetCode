Given an integer array nums that may contain duplicates, return all possible subsets (the power set) The solution set must not contain duplicate subsets. Return the solution in any order.


Example 1:

Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
Example 2:

Input: nums = [0]
Output: [[],[0]]
 

Constraints:

1 <= nums.length <= 10
-10 <= nums[i] <= 10

Code: Beats 100% Time Complexity O(n * 2^N)
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        backtrack(nums, result, new ArrayList<>(), 0);
        return result;
    }

    public void backtrack(int[] nums, List<List<Integer>> result, List<Integer> curr, int index){
        result.add(new ArrayList<>(curr));

        for (int i = index; i < nums.length; i++){
            if (i > index && nums[i] == nums[i-1]) continue;
            curr.add(nums[i]);
            backtrack(nums, result, curr, i + 1);
            curr.remove(curr.size() -1);
        }
    }
}

Code Explanation: 
- For this problem, we want to find the list of ALL subsets where the subset can contain duplicate numbers (separate numbers within the array that happen to have the same value) but we still cannot have duplicate subsets
- To do this, we want to sort the array. This is because even if we have two of the same number, when we are iterating through the array in the backtracking function, we need to skip over duplicates, otherwise this will create a duplicate subset. For example, if we have 1,2,2,3. We process the first two, and once we've evaluated all the backtracking cases for it recursively, the call stack returns to branch 1. We then skip over the first 2, use the second two, and now we produce the subset 1,2,3. The same subset we produced when we processed the first two, and skipped the second
- For this reason, we sort the array, and within the for loop in the backtrack function, we skip over duplicate values to ensure that we don't reprocess the same number at the same depth, as this would result in the same subsets again
- The time complexity is O(n * 2^n) bc in the worst case, there are at most two choices for each number (to include or skip). And for each chocie we copy over to the results list which takes O(N) time
