Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.


Example 1:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
Example 2:

Input: nums = [0,1]
Output: [[0,1],[1,0]]
Example 3:

Input: nums = [1]
Output: [[1]]
 

Constraints:

1 <= nums.length <= 6
-10 <= nums[i] <= 10
All the integers of nums are unique.

Code: Beats 100% Time Complexity: O(n * n!) 
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(nums, result, new ArrayList<>());
        return result;
    }

    public void backtrack(int[] nums, List<List<Integer>> result, List<Integer> curr){
        if (curr.size() == nums.length){
            result.add(new ArrayList<>(curr));
            return; 
        }

        for (int i: nums){
            if (curr.contains(i)) continue; 
            curr.add(i);
            backtrack(nums, result, curr);
            curr.remove(curr.size() -1);
        }
    }
}

Code Explanation: 
- This is another backtracking problem, except for this one, we don't care about order. We want to find all possible combinations of the same 3 digits in every order.
- We create a backtracking function and pass in the nums array, the result, and a curr list
- We don't pass in an index variable since we don't actually want to enforce a left-to-right process, since we don't care about the order here
- We do the standard processing within the backtrack function and within the for loop, we want to make sure we don't add the same number twice
- This will eventually give us our answer in n! calls but in each call we also copy to our results array, which takes O(n) time, resulting in the time complexity of O(n * n!) 
