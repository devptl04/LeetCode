A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.

Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.

Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.
 
Constraints:
The number of nodes in the tree is in the range [1, 3 * 104].
-1000 <= Node.val <= 1000

Code: Beats 100% Time Complexity: O(n)
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return max; 
    }

    public int dfs(TreeNode root){
        if (root == null) return 0; 
        int left = Math.max(0, dfs(root.left));
        int right = Math.max(0, dfs(root.right));
        int curr = root.val + left + right; 
        max = Math.max(max, curr);
        return root.val + Math.max(left, right);
    }
}

Code Explanation: 
- For this problem, we want to find the max path value. In order to do this we utilize dfs. We traverse down the left and right trees and keep track of the current max of its children using left and right.
- If a child node's cumulative value is negative, we just default it to 0 (essentially just skipping over it)
- We then calcualte the current sum we have and append to max accordingly
- Then we return the best path that we found (since we cannot have splits), meaning if we have a parent node with two children. The child nodes cannot both be factored, we have to choose the highest valued path, so we include both the current value and the max child value in our path calculations 
- Since we traverse the graph once, we have a O(n) time complexity 
