Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows:

The left subtree of a node contains only nodes with keys strictly less than the node's key.
The right subtree of a node contains only nodes with keys strictly greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 
Example 1:
Input: root = [2,1,3]
Output: true

Example 2:
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
 
Constraints:
The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1

Code: Beats 100% Time Complexity: O(n) 
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root, null, null);
    }

    public boolean dfs(TreeNode root, TreeNode lower, TreeNode upper){
        if (root == null) return true; 

        if (lower != null){
            if (root.val <= lower.val) return false; 
        }
        if (upper != null){
            if (root.val >= upper.val) return false;
        }

        return dfs(root.left, lower, root) && dfs(root.right, root, upper);
    }
}

Code Explanation: 
- For this problem, we want to see if we have a valid binary search tree, meaning that the order integrity of the nodes must be upheld
- To solve this, we perform DFS while checking each respective nodes upper and lower bound. Its upper bound is the value that it cannot be greater than and vice versa for lower bound
- We first call this this dfs function, where initally the upper and lower bounds are null since the root cannot have any boundary checks. 
- Within the dfs function, if the boundary is null (means that we are either at the left most or right most) side of the tree and so we can skip that check. If the current value is greater than the lower bound then we know the binary tree is invalid that our order integrity is wrong. Vice versa with the upper check
- We then want to recursively call to both the left and right sides of the tree. For traversing the left side, we know that every value must be less than its parent, so the new upper bound becomes root. For the right branch, we know that every node must be greater than its parent, so the root becomes the lower limit
- We are doing dfs and traverse the list once, so this runs in linear time 
