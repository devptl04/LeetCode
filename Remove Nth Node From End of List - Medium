Given the head of a linked list, remove the nth node from the end of the list and return its head.


Example 1:
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:
Input: head = [1], n = 1
Output: []

Constraints:
The number of nodes in the list is sz.
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz


Code: 0ms | Beats 100% | Time Complexity: O(n) & Space Complexity: 0(1)
public ListNode removeNthFromEnd(ListNode head, int n) {
       ListNode dummy = new ListNode(0);
       dummy.next = head; 

       ListNode fast = dummy;
       ListNode slow = dummy;

       for (int i =0; i <= n; i++){
            fast = fast.next; 
       }

       while (fast != null){
        fast = fast.next;
        slow = slow.next; 
       }

       slow.next = slow.next.next; 

       return dummy.next; 

    }
}

Code Explanation:
- For this problem, we want to remove the Nth node from the end of the list. In order to do this in the most optimal time, we want to just run through the linked list once. We utilize a two-pointer approach to do this. 
- We initialize a dummy pointer, which we can return at the end for the list. (We do this to handle edge cases like instances where we remove the first node in the list, where we would then not be able to just return head.next) 
- We then create a fast and slow pointer, and we increment the fast pointer n+1 spots. We do this because we want the slow pointer to be a spot behind the actual node we want to remove, so we can effectively skip over it
- Once we do this, we increment both the slow and fast pointers until fast reaches the end of the list. Once it does, we know slow is at the node right before removal, and we skip over the next node accordingly. 
- We utilize our dummy node that we created and return
