Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space.

Example 1:
Input: nums = [1,3,4,2,2]
Output: 2

Example 2:
Input: nums = [3,1,3,4,2]
Output: 3

Constraints:

1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
All the integers in nums appear only once except for precisely one integer which appears two or more times.

Code: Beats 88.13% Time Complexity: O(n)
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = nums[0];
        int fast = nums[0];

        while (true){
            slow = nums[slow];
            fast = nums[nums[fast]];
            if (slow == fast){
                break; 
            }
        }

        slow = nums[0];
        while (slow != fast){
            slow = nums[slow];
            fast = nums[fast];
        }

        return slow;
    }
}

Code Explanation: 
- For this problem, we are given an array of size n+1 with digits ranging from 1 to n. We want to find the duplicate value, and we can model the array as a linked list where each index points to the next node using the value at that index (i -> nums[i]).
- We use Floyd's Tortoise and Hare algorithm by creating a slow and fast pointer. We move slow by one step and fast by two steps until they meet.
- When they meet, it confirms there's a cycle (due to the duplicate), but the meeting point is not necessarily the start of the cycleâ€”just a point inside it.
- We then reset the slow pointer to the start of the array and move both pointers at the same pace. Where they meet this time is the start of the cycle.
- This works because the distance from the start to the cycle entrance equals the distance from the meeting point to the cycle entrance (within the loop), so both pointers arrive at the duplicate (entry point) at the same time.
